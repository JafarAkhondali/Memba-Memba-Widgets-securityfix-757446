/**
 * Copyright (c) 2013-2018 Memba Sarl. All rights reserved.
 * Sources at https://github.com/Memba
 */

// TODO: validators
// TODO: highlight selection from API
// TODO: help tooltips - row.help

// https://github.com/benmosher/eslint-plugin-import/issues/1097
// eslint-disable-next-line import/extensions, import/no-unresolved
import $ from 'jquery';
import 'kendo.core';
import 'kendo.validator';
import assert from '../common/window.assert.es6';
import CONSTANTS from '../common/window.constants.es6';
import Logger from '../common/window.logger.es6';
import editors from '../tools/util.editors.es6';

const {
    attr,
    destroy,
    format,
    template,
    toHyphens,
    ui,
    ui: { plugin, Widget }
} = window.kendo;
const logger = new Logger('widgets.propertygrid');
const NS = '.kendoPropertyGrid';
const RX_PRIVATE = /^_/;
const TBODY = 'tbody';
const TCELL = 'td[role="gridcell"]';
const WIDGET_CLASS = 'k-grid k-widget kj-propertygrid';
const HANDLE_CLASS = 'k-resize-handle';

/**
 * PropertyGrid
 * @class PropertyGrid
 * @extends Widget
 */
const PropertyGrid = Widget.extend({
    /**
     * Init
     * @constructor init
     * @param element
     * @param options
     */
    init(element, options) {
        // base call to widget initialization
        Widget.fn.init.call(this, element, options);
        logger.debug({ method: 'init', message: 'widget initialized' });
        this._render();
        this._addValidator();
        this.refresh();
    },

    /**
     * Options
     * @property options
     */
    options: {
        name: 'PropertyGrid',
        value: null, // Cannot be undefined
        rows: null, // Cannot be undefined and [] means no row to display
        validation: null, // Cannot be undefined
        templates: {
            row:
                '<tr role="row"><td role="gridcell">#: title #</td><td role="gridcell"></td></tr>',
            altRow:
                '<tr class="k-alt" role="row"><td role="gridcell">#: title #</td><td role="gridcell"></td></tr>'
        },
        messages: {
            property: 'Property',
            value: 'Value'
        }
    },

    /**
     * Value is the object whose properties are displayed in the property grid
     * @param value
     * @returns {*}
     */
    value(value) {
        const that = this;
        if ($.type(value) === CONSTANTS.OBJECT || $.type(value) === CONSTANTS.NULL) {
            if (that.options.value !== value) {
                that.options.value = value;
                that.refresh();
            }
        } else if ($.type(value) === CONSTANTS.UNDEFINED) {
            return that.options.value;
        } else {
            throw new TypeError(
                '`value` is expected to be an object if not null or undefined'
            );
        }
    },

    /**
     * Rows setter/getter (TODO: Do we really need/use this?? Seems to be someting for setOptions)
     * @param rows
     * @returns {*}
     */
    rows(rows) {
        assert.isArray(rows, assert.format(assert.messages.isArray.default));
        let ret;
        if ($.type(rows) === CONSTANTS.UNDEFINED) {
            ret = this.options.rows;
        } else if (rows !== this.options.rows) {
            this.options.rows = rows;
            // that.refresh();
        }
        return ret;
    },

    /**
     * Builds the widget layout
     * @method _render
     * @private
     */
    _render() {
        const that = this;
        const element = that.element;
        const messages = that.options.messages;
        that.wrapper = element;
        element.addClass(WIDGET_CLASS); // the kendo.ui.Grid has style="height:..."
        // add column headers (matches markup generated by kendo.ui.Grid)
        if (
            $.type(messages.property) === CONSTANTS.STRING &&
            $.type(messages.value) === CONSTANTS.STRING
        ) {
            element.append(
                `${'<div class="k-grid-header" style="padding-right:17px;">' +
                    '<div class="k-grid-header-wrap">' +
                    '<table role="grid">' +
                    '<colgroup><col style="width:35%;"><col style="width:65%;"></colgroup>' +
                    '<thead role="rowgroup"><tr role="row">' +
                    '<th role="columnheader" class="k-header">'}${
                    messages.property
                }</th>` +
                    `<th role="columnheader" class="k-header">${
                        messages.value
                    }</th>` +
                    `</tr></thead>` +
                    `</table>` +
                    `</div>` +
                    `</div>`
            );
        }
        // Add property grid content (matches markup generated by kendo.ui.Grid)
        element.append(
            '<div class="k-grid-content">' + // the kendo.ui.Grid has style="height:..."
                '<table role="grid" style="height: auto;">' +
                '<colgroup><col style="width:35%;"><col style="width:65%;"></colgroup>' +
                '<tbody role="rowgroup">' +
                // ------------------------------ This is where rows are added
                '</tbody>' +
                '</table>' +
                '</div>'
        );
        // Add column resizing
        that._addColumnResizing();
    },

    /**
     * Refresh
     * @method refresh
     */
    refresh() {
        const that = this;
        const element = that.element;
        const options = that.options;
        const properties = that.value();
        const tbody = element.find(TBODY).first();

        // kendo.unbind(tbody);
        kendo.destroy(tbody);
        tbody.find('*').off();
        tbody.empty();

        if ($.type(properties) !== CONSTANTS.OBJECT) {
            return;
        }

        const rowTemplate = kendo.template(options.templates.row);
        const altRowTemplate = kendo.template(options.templates.altRow);
        const rows = that._buildRows();
        let discarded = 0;

        for (let idx = 0; idx < rows.length; idx++) {
            const row = rows[idx];
            if (row) {
                const template =
                    (idx - discarded) % 2 === 1 ? altRowTemplate : rowTemplate;

                // Append the HTML table cells with the title in the left cell
                tbody.append(template({ title: row.title }));

                // Add the editor to the right cell
                const container = tbody.find(TCELL).last();
                const settings = $.extend({}, row, { model: properties });
                row.editor(container, settings);
            } else {
                discarded++;
            }
        }

        // Bind properties of property grid
        kendo.bind(tbody, properties, kendo.ui, kendo.mobile.ui);

        // Reposition column resizing handle
        that._resize();

        logger.debug({ method: 'refresh', message: 'widget refreshed' });
    },

    /**
     * Build rows
     * @returns {Array}
     * @private
     */
    _buildRows() {
        const that = this;
        const options = that.options;
        const rows = [];
        const hasRows = $.isArray(options.rows); // && options.rows.length > 0;

        // options.rows gives:
        // - field (name) - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.field
        // - title        - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.title
        // - format       - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.format
        // - template     - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.template
        // - editor       - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.editor
        // - values?????  - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.values
        // - encoded????  - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.encoded
        // - attributes   - http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns.attributes

        // options.fields gives: - http://docs.telerik.com/kendo-ui/api/javascript/data/model#methods-Model.define
        // - type
        // - editable
        // - nullable
        // - defaultValue - see options.value.defaults
        // - validation

        // options.value gives
        // - type
        // - value (for data-binding)

        function buildRows(properties, hashedOptionRows, path) {
            const fields = properties.fields;
            const defaults = properties.defaults;

            for (const prop in properties) {
                // Select only public properties that are not functions (discards _events)
                if (
                    properties.hasOwnProperty(prop) &&
                    !RX_PRIVATE.test(prop) &&
                    !$.isFunction(properties[prop]) &&
                    // if rows are designated in this.options.rows, only select these rows
                    (!hasRows || hashedOptionRows.hasOwnProperty(prop))
                ) {
                    // TODO: the following line has been modified to care for complex values like CharGrid, which should be edited as a whole in a specific editor
                    // if ($.type(properties[prop]) === CONSTANTS.OBJECT) {
                    if (
                        $.type(properties[prop]) === CONSTANTS.OBJECT &&
                        properties[prop].fields
                    ) {
                        buildRows(
                            properties[prop],
                            hashedOptionRows[prop] || {},
                            path.length === 0 ? prop : `${path}.${prop}`
                        );
                    } else {
                        const row = {
                            attributes:
                                hasRows &&
                                hashedOptionRows[prop] &&
                                hashedOptionRows[prop].attributes
                                    ? hashedOptionRows[prop].attributes
                                    : undefined,
                            // defaultValue
                            editable: !(
                                fields &&
                                fields[prop] &&
                                fields[prop].editable === false
                            ),
                            editor:
                                hasRows &&
                                hashedOptionRows[prop] &&
                                hashedOptionRows[prop].editor
                                    ? hashedOptionRows[prop].editor
                                    : undefined,
                            field: path.length === 0 ? prop : `${path}.${prop}`,
                            format:
                                hasRows &&
                                hashedOptionRows[prop] &&
                                hashedOptionRows[prop].format
                                    ? hashedOptionRows[prop].format
                                    : undefined,
                            // nullable
                            template:
                                hasRows &&
                                hashedOptionRows[prop] &&
                                hashedOptionRows[prop].template
                                    ? hashedOptionRows[prop].template
                                    : undefined,
                            title:
                                hasRows &&
                                hashedOptionRows[prop] &&
                                hashedOptionRows[prop].title
                                    ? hashedOptionRows[prop].title
                                    : util.formatTitle(prop),
                            type: util.getType(
                                fields && fields[prop],
                                defaults && defaults[prop],
                                properties[prop]
                            )
                        };

                        // Add validation rules to attributes
                        // See https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
                        if (fields && fields[prop] && fields[prop].validation) {
                            const attributes = {
                                required: fields[prop].validation.required
                                    ? true
                                    : undefined,
                                min: fields[prop].validation.min,
                                max: fields[prop].validation.max,
                                maxlength: fields[prop].validation.maxlength, // See http://docs.telerik.com/kendo-ui/aspnet-mvc/helpers/editor/how-to/add-max-length-validation
                                step: fields[prop].validation.step,
                                pattern: fields[prop].validation.pattern,
                                type: fields[prop].validation.type
                            };
                            row.attributes = $.extend(
                                {},
                                row.attributes,
                                attributes
                            );
                        }

                        util.optimizeEditor(row);

                        // TODO: the following line has been modified to care for complex values like CharGrid, which have a type of undefined
                        // if (row.type) {
                        if (hasRows) {
                            // With this.options.rows, only designated properties are displayed
                            rows[hashedOptionRows[prop]._index] = row;
                        } else {
                            // Without this.options.rows, all public properties are displayed
                            rows.push(row);
                        }
                        // }
                    }
                }
            }
        }

        buildRows(that.value(), util.hash(options.rows), '');
        return rows;
    },

    /**
     * _resize is called by Widget.resize and kendo.resize to reposition the handle used to resize columns
     * This is especially required in the Kidoju editor because the handle is not correctly positionned
     * because the PropertyGrid widget is created withng a PanelBar which is initially collapsed (hidden)
     * @private
     */
    _resize(/* size, force */) {
        const element = this.element;
        // reposition the resize handle
        const handle = element.children(`.${HANDLE_CLASS}:visible`);
        const propertyColumn = element.find(
            '.k-grid-content>table>tbody>tr>td:first-child'
        );
        if (handle.length && propertyColumn.length) {
            handle.css({
                left: propertyColumn.outerWidth() - handle.outerWidth() / 2
            });
        }
    },

    /**
     * Add column resizing
     * @private
     */
    _addColumnResizing() {
        const that = this;
        const element = that.element;
        const headerColGroup = element.find(
            '.k-grid-header>.k-grid-header-wrap>table>colgroup'
        );
        const contentColGroup = element.find('.k-grid-content>table>colgroup');
        const tbody = element.find('.k-grid-content>table>tbody');
        let propertyCell;
        let valueCell;
        // var call;
        if (!element.children(`.${HANDLE_CLASS}`).length) {
            $('<div />')
                .addClass(HANDLE_CLASS)
                .appendTo(element);
        }
        const resizableWidget = element.data('kendoResisable');
        if (!(resizableWidget instanceof ui.Resizable)) {
            element.kendoResizable({
                handle: `.${HANDLE_CLASS}`,
                hint(handle) {
                    const clone = handle.clone();
                    handle.hide();
                    return clone;
                },
                start(e) {
                    // Property and value cells do not exist when initializing element.kendoResizable
                    propertyCell = tbody.find('tr>td:first-child');
                    valueCell = tbody.find('tr>td:last-child');
                    // call = Date.now();
                },
                resize(e) {
                    // if (Date.now() - call > 25) { // throttle
                    setTimeout(() => {
                        const hint = $(e.elementUnderCursor);
                        // td cell do not exist when
                        const propertyWidth = propertyCell.outerWidth();
                        const valueWidth = valueCell.outerWidth();
                        const shift =
                            e.pageX -
                            element.offset().left -
                            e.offsetX +
                            hint.outerWidth() / 2 -
                            propertyWidth;
                        // Testing prevents a flickering effect when resizing but there must be a better way
                        // Also this requires that resizing be performed with slow mouse/touch moves
                        if (Math.abs(shift) < 50) {
                            const propertyPercent =
                                (propertyWidth + shift) /
                                (propertyWidth + valueWidth);
                            const valuePercent =
                                (valueWidth - shift) /
                                (propertyWidth + valueWidth);
                            headerColGroup
                                .children('col:first-child')
                                .width(`${propertyPercent}%`);
                            headerColGroup
                                .children('col:last-child')
                                .width(`${valuePercent}%`);
                            contentColGroup
                                .children('col:first-child')
                                .width(`${propertyPercent}%`);
                            contentColGroup
                                .children('col:last-child')
                                .width(`${valuePercent}%`);
                        }
                        // call = Date.now();
                    }, 0);
                    // }
                },
                resizeend(e) {
                    const propertyWidth = element
                        .find('.k-grid-content>table>tbody>tr>td:first-child')
                        .outerWidth();
                    const handle = $(e.currentTarget);
                    handle
                        .css({ left: propertyWidth - handle.outerWidth() / 2 })
                        .show();
                    // Resize all widgets in the property grid
                    element.children().each((index, child) => {
                        kendo.resize($(child));
                    });
                }
            });
        }
    },

    /**
     * Gets/Set validation rules
     * See http://docs.telerik.com/kendo-ui/api/javascript/ui/validator
     * @param validation
     * @returns {*}
     */
    validation(validation) {
        const that = this;
        if ($.type(validation) === CONSTANTS.OBJECT || $.type(validation) === CONSTANTS.NULL) {
            if (validation !== that.options.validation) {
                that.options.validation = validation;
                that._removeValidator();
                that._addValidator();
            }
        } else if ($.type(validation) !== CONSTANTS.UNDEFINED) {
            return that.options.validation;
        } else {
            throw new TypeError(
                '`validation` is expected to be an object if not null or undefined'
            );
        }
    },

    /**
     * Add validator
     * See http://docs.telerik.com/kendo-ui/api/javascript/ui/validator
     * @private
     */
    _addValidator() {
        const that = this;
        if (!(that._validator instanceof kendo.ui.Validator)) {
            that._validator = that.element
                .kendoValidator(that.options.validation)
                .data('kendoValidator');
        }
    },

    /**
     * Remove validator
     * @private
     */
    _removeValidator() {
        const that = this;
        if (that._validator instanceof kendo.ui.Validator) {
            that._validator.destroy();
        }
    },

    /**
     * Get the error messages if any. (call validate first)
     * @returns {*}
     */
    errors() {
        const that = this;
        if (that._validator instanceof kendo.ui.Validator) {
            return that._validator.errors();
        }
    },

    /**
     * Hides the validation messages.
     * @returns {*}
     */
    hideMessages() {
        const that = this;
        if (that._validator instanceof kendo.ui.Validator) {
            return that._validator.hideMessages();
        }
    },

    /**
     * Validates the input element(s) against the declared validation rules.
     * @returns {*}
     */
    validate() {
        const that = this;
        if (that._validator instanceof kendo.ui.Validator) {
            return that._validator.validate();
        }
    },

    /**
     * Validates the input element against the declared validation rules.
     * @param input
     * @returns {*}
     */
    validateInput(input) {
        const that = this;
        if (that._validator instanceof kendo.ui.Validator) {
            return that._validator.validateInput(input);
        }
    },

    /**
     * Destroy
     * @method destroy
     */
    destroy() {
        const that = this;
        const element = that.element;
        that._removeValidator();
        element.off(NS).removeClass(WIDGET_CLASS);
        Widget.fn.destroy.call(this);
        kendo.destroy(element);
    }
});

/**
 * Registration
 */
plugin(PropertyGrid);

/** *******************************************************************************
 * Helpers
 ******************************************************************************** */

var util = {
    /**
     * Return a hash object from an array of rows
     * @param rows
     * @returns {{}}
     */
    hash(rows) {
        const ret = {};
        if ($.isArray(rows)) {
            $.each(rows, (index, row) => {
                // check fields like attributes.src
                const hierarchy = row.field.split('.');
                let obj = ret;
                for (let i = 0; i < hierarchy.length; i++) {
                    obj = obj[hierarchy[i]] = obj[hierarchy[i]] || {};
                }
                obj._index = index;
                Object.keys(row).forEach(key => {
                    obj[key] = row[key];
                });
            });
        }
        return ret;
    },

    /**
     * Format a fieldName into a title
     * e.g. return `My Field Title` from `myFieldTitle`
     * @param fieldName
     * @returns {*}
     */
    formatTitle(fieldName) {
        // See http://stackoverflow.com/questions/6142922/replace-a-regex-capture-group-with-uppercase-in-javascript
        return toHyphens(fieldName)
            .replace(/(^\w|-\w)/g, v => v.replace('-', ' ').toUpperCase());
    },

    /**
     * Get the field type
     * @param field
     * @param defaultValue
     * @param value
     */
    getType(field, defaultValue, value) {
        const fieldTypes = ['string', 'number', 'boolean', 'date'];
        let type;
        if (field && fieldTypes.indexOf(field.type) > -1) {
            return field.type;
        }
        if (
            $.type(defaultValue) !== CONSTANTS.UNDEFINED &&
            $.type(defaultValue) !== CONSTANTS.NULL
        ) {
            type = $.type(defaultValue);
            return fieldTypes.indexOf(type) > -1 ? type : undefined;
        }
        if ($.type(value) !== CONSTANTS.UNDEFINED && $.type(value) !== CONSTANTS.NULL) {
            type = $.type(value);
            return fieldTypes.indexOf(type) > -1 ? type : undefined;
        }
        // By default
        return CONSTANTS.STRING;
    },

    /**
     * Improve the editor set in row
     * @param row
     */
    optimizeEditor(row) {
        if (!row.editable) {
            row.editor = editors.span;
            return;
        }

        // INPUT_TYPES = 'color,date,datetime,datetime-local,email,month,number,range,search,tel,text,time,url,week',
        // We have left: button, checkbox, file, hidden, image, password, radio, reset, submit
        // SEE:http://www.w3schools.com/tags/att_input_type.asp

        // If row.editor is a function, there is nothing to optimize
        if ($.isFunction(row.editor)) {
            return;
        }

        // If row editor is a string
        if ($.type(row.editor) === CONSTANTS.STRING) {
            row.editor = row.editor.toLowerCase();

            // If it designates a public well-known editor
            if (
                row.editor.length &&
                !RX_PRIVATE.test(row.editor) &&
                $.isFunction(editors[row.editor])
            ) {
                row.editor = editors[row.editor];
                return;
            }

            // If it designates a kendo UI widget that works with an input
            const widgets = [
                'colorpicker',
                'datepicker',
                'datetimepicker',
                'maskedtextbox',
                'multiinput',
                'numerictextbox',
                'rating',
                'slider',
                'switch',
                'timepicker'
            ];
            if (
                widgets.indexOf(row.editor) > -1 &&
                (kendo
                    .rolesFromNamespaces(kendo.ui)
                    .hasOwnProperty(row.editor) ||
                    kendo
                        .rolesFromNamespaces(kendo.mobile.ui)
                        .hasOwnProperty(row.editor))
            ) {
                row.attributes = $.extend(
                    {},
                    row.attributes,
                    util.getRoleBinding(row.editor)
                );
                row.editor = editors.input; // editors._kendoInput;
                return;
            }
        }

        // At this stage, there should be no row editor
        row.editor = undefined;

        // If there is a template, use the corresponding editor
        if ($.type(row.template) === CONSTANTS.STRING && row.template.length) {
            row.editor = editors._template;
            return;
        }

        // Otherwise we can only rely on data type
        switch (row.type) {
            case CONSTANTS.NUMBER:
                row.attributes = $.extend(
                    {},
                    row.attributes,
                    util.getRoleBinding('numerictextbox')
                );
                row.editor = editors.input; // editors._kendoInput;
                break;
            case CONSTANTS.BOOLEAN:
                row.attributes = $.extend(
                    {},
                    row.attributes,
                    util.getRoleBinding('switch')
                );
                row.editor = editors.input; // editors._kendoInput;
                break;
            case CONSTANTS.DATE:
                row.attributes = $.extend(
                    {},
                    row.attributes,
                    util.getRoleBinding('datepicker')
                );
                row.editor = editors.input; // editors._kendoInput;
                break;
            default:
                // CONSTANTS.STRING
                row.attributes = $.extend({ type: 'text' }, row.attributes);
                row.editor = editors.input;
        }
    },

    getRoleBinding(role) {
        const binding = {};
        if ($.type(role) === CONSTANTS.STRING && role.length) {
            binding[kendo.attr('role')] = role;
        }
        return binding;
    }
};

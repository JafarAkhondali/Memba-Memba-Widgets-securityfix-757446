import { isArray } from '../common/types';

import {
    getEnvironmentInfo,
    getInfo,
    unicodeCharToLatex,
    MacroDictionary,
} from './definitions';
import { stringToColor } from './color';
import { convertDimenToEm } from './font-metrics';
import { Token, tokenize } from './lexer';
import { Atom, Colspec, BBoxParam } from './atom';
import { parseTokens } from './modes';
import { FunctionDefinition } from './definitions-utils';
import { ParserErrorListener, MacroDefinition, Style } from '../public/core';
import { ParseModePrivate } from './context';

function tokensToString(tokens: Token[]): string {
    let hasParamToken = false;
    const result = tokens
        .map((token) => {
            if (token.type === 'literal') {
                return token.value;
            }
            if (token.type === '{') {
                return '{';
            }
            if (token.type === '}') {
                return '}';
            }
            if (token.type === 'command') {
                return '\\' + token.value;
            }
            if (token.type === 'placeholder') {
                return '#?';
            }
            if (token.type === '#') {
                hasParamToken = true;
                return '#' + token.value;
            }
            if (token.type === 'space') {
                return ' ';
            }
            if (token.type === '$') {
                return '$';
            }
            if (token.type === '$$') {
                return '$$';
            }
            console.error('Unexpected token type ', token.type);
            return '';
        })
        .join('');
    return hasParamToken ? '' : result;
}

/**
 * A parser transforms a list of tokens into a list of Atom.
 *
 * @param {Token[]} tokens - An array of tokens generated by the lexer.
 * @param {Object.<string>} [args] - An optional list of arguments. `#n` tokens will be
 * substituted with the corresponding element in the args object. This is used
 * when parsing macros.
 * @class module:core/parser#Parser
 * @property {Token[]} tokens - An array of tokens generated by the lexer.
 * @property {Object.<string>} args - Optional arguments to substitute the `#` token.
 * @property {Object.<string, string>} macros - A dictionary of objects, index by the name of
 * the macro, with the following keys:
 *    * args: an integer, the number of arguments, default 0. They can be referenced as #0,
 *       #1, #2... inside the definition of the macro
 *    * def: a string, the definition of the macro, which can reference other macros
 * @property {number} index - The current token to be parsed: index in `this.tokens`
 * @property {Atom[]} mathList - Accumulated result of the parsing by
 * `parseAtom()`
 * @property {object} style - The font, weight, color, etc. to apply to the
 * upcoming tokens
 * @property {string} parseMode - The parse mode indicates the syntax rules to
 * use to parse the upcoming tokens.
 *  Valid values include:
 *  - `'math'`: spaces are ignored, math functions are allowed
 *  - `'text'`: spaces are accounted for, math functions are ignored
 *  - `'string'`
 *  - `'color'`: color name, hex value: `'#fff'`, `'#a0a0a0'`
 *  - `'number'`: `+/-12.56`
 *  - `'dimen'`: `'25mu'`, `'2pt'`
 *  - `'skip'`: `'25mu plus 2em minus fiLll'`, `'2pt'`
 *  - `'colspec'`: formating of a column in tabular environment, e.g. `'r@{.}l'`
 * @property {boolean} tabularMode - When in tabular mode, `'&'` is interpreted as
 *  a column separator and `'\'` as a row separator. Used for matrixes, etc...
 * @property {number} endCount - Counter to prevent deadlock. If `end()` is
 * called too many times (1,000) in a row for the same token, bail.
 */
class Parser {
    tokens: Token[];
    args: (string | Atom[])[];
    macros: MacroDictionary;

    onError: ParserErrorListener;
    index = 0;
    mathList: Atom[] = [];
    style: Style = {};
    parseMode: ParseModePrivate = 'math';
    smartFence = false;
    tabularMode = false;
    endCount = 0;

    constructor(
        tokens: Token[],
        args: (string | Atom[])[],
        macros: MacroDictionary,
        onError: ParserErrorListener
    ) {
        this.tokens = tokens;
        this.args = args;
        this.macros = macros;
        this.onError = (err) =>
            onError({
                before: tokensToString(
                    this.tokens.slice(this.index, this.index + 10)
                ),
                after: tokensToString(
                    this.tokens.slice(Math.max(0, this.index - 10), this.index)
                ),
                ...err,
            });
    }
    swapMathList(newMathList: Atom[] = []): Atom[] {
        const result = this.mathList;
        this.mathList = newMathList;
        return result;
    }
    swapParseMode(mode: ParseModePrivate): ParseModePrivate {
        const result = this.parseMode;
        this.parseMode = mode;
        return result;
    }
    /**
     * True if we've reached the end of the token stream.
     */
    end(): boolean {
        // To prevent a deadlock, count how many times end() is called without the
        // index advancing. If it happens more than 1,000 times in a row,
        // assume something is broken and pretend the stream is finished.
        this.endCount++;
        return this.index >= this.tokens.length || this.endCount > 1000;
    }
    get(): Token | null {
        this.endCount = 0;
        return this.index < this.tokens.length
            ? this.tokens[this.index++]
            : null;
    }
    peek(offset = 0): Token | null {
        const index = this.index + offset;
        return index < this.tokens.length ? this.tokens[index] : null;
    }
    /**
     * Return the last atom of the math list
     * If there isn't one, insert a `msubsup` and return it.
     */
    lastMathAtom(): Atom {
        const lastType =
            this.mathList.length === 0
                ? 'none'
                : this.mathList[this.mathList.length - 1].type;
        if (lastType !== 'mop' && lastType !== 'msubsup') {
            // ZERO WIDTH SPACE
            const lastAtom = new Atom(this.parseMode, 'msubsup', '\u200b');
            this.mathList.push(lastAtom);
        }
        return this.mathList[this.mathList.length - 1];
    }
    /**
     * @return True if the next token is of the specified type
     */
    hasToken(type: string): boolean {
        const index = this.index;
        return index < this.tokens.length
            ? this.tokens[index].type === type
            : false;
    }
    /**
     * @return True if the next token is of type `'literal` and has the
     * specified value. If `value` is empty, return true if the token is of type
     * `'literal'`
     */
    hasLiteral(value = ''): boolean {
        const index = this.index;
        return index < this.tokens.length
            ? this.tokens[index].type === 'literal' &&
                  (!value || this.tokens[index].value === value)
            : false;
    }
    /**
     * @param pattern
     * @return True if the next token is of type `'literal` and matches
     * the specified regular expression pattern.
     */
    hasLiteralPattern(pattern: RegExp): boolean {
        return (
            this.hasToken('literal') &&
            pattern.test(this.tokens[this.index].value as string)
        );
    }
    hasCommand(command: string): boolean {
        console.assert(
            command === '\\' || command.charAt(0) !== '\\',
            'hasCommand() does not require a \\'
        );
        const index = this.index;
        return index < this.tokens.length
            ? this.tokens[index].type === 'command' &&
                  this.tokens[index].value === command
            : false;
    }
    hasInfixCommand(): boolean {
        const index = this.index;
        if (
            index < this.tokens.length &&
            this.tokens[index].type === 'command'
        ) {
            const info = getInfo(
                '\\' + this.tokens[index].value,
                this.parseMode,
                this.macros
            );
            if (info?.mode && !info.mode.includes(this.parseMode)) return false;
            return info?.infix;
        }
        return false;
    }
    hasColumnSeparator(): boolean {
        const index = this.index;
        return this.tabularMode && index < this.tokens.length
            ? this.tokens[index].type === 'literal' &&
                  this.tokens[index].value === '&'
            : false;
    }
    hasRowSeparator(): boolean {
        const index = this.index;
        return this.tabularMode && index < this.tokens.length
            ? this.tokens[index].type === 'command' &&
                  (this.tokens[index].value === '\\' ||
                      this.tokens[index].value === 'cr')
            : false;
    }
    parseColumnSeparator(): boolean {
        if (this.hasColumnSeparator()) {
            this.index++;
            return true;
        }
        return false;
    }
    /**
     * Return the appropriate value for a placeholder, either a default
     * one, or if a value was provided for #? via args, that value.
     */
    placeholder(): Atom[] {
        if (!this.args || typeof this.args['?'] === 'undefined') {
            // U+2753 = BLACK QUESTION MARK ORNAMENT
            const result = new Atom(
                this.parseMode,
                'placeholder',
                '?',
                this.style
            );
            result.captureSelection = true;
            return [result];
        }
        if (typeof this.args?.['?'] === 'string') {
            // If there is a specific value defined for the placeholder,
            // use it.
            return parseString(
                this.args['?'],
                this.parseMode,
                null,
                this.macros,
                false,
                this.onError
            );
        }
        return this.args['?'];
    }
    hasImplicitCommand(commands: string[]): boolean {
        if (this.index < this.tokens.length) {
            const token = this.tokens[this.index];
            if (token.type === 'command') {
                return commands.includes(token.value as string);
            }
        }
        return false;
    }
    parseRowSeparator(): boolean {
        if (this.hasRowSeparator()) {
            this.index++;
            return true;
        }
        return false;
    }

    parseToken(type: string): boolean {
        if (this.hasToken(type)) {
            this.index++;
            return true;
        }
        return false;
    }
    skipWhitespace(): boolean {
        let found = false;
        while (this.hasToken('space')) {
            this.index++;
            found = true;
        }
        return found;
    }
    skipUntilToken(type: string): void {
        while (!this.end() && !this.parseToken(type)) {
            this.get();
        }
    }
    parseArguments(
        info: FunctionDefinition
    ): [
        ParseModePrivate,
        (string | number | BBoxParam | Colspec[] | Atom | Atom[])[]
    ] {
        if (!info || !info.params) return ['', []];
        let explicitGroup: ParseModePrivate = '';
        const args: (
            | string
            | number
            | BBoxParam
            | Colspec[]
            | Atom
            | Atom[]
        )[] = [];
        let i = info.infix ? 2 : 0;
        while (i < info.params.length) {
            const param = info.params[i];
            // Parse an argument
            if (param.isOptional) {
                args.push(this.scanOptionalArg(param.type));
            } else if (param.type.endsWith('*')) {
                // For example 'math*'.
                // In this case, indicate that a 'yet-to-be-parsed'
                // argument (and 'explicit group') is present
                explicitGroup = param.type.slice(0, -1) as ParseModePrivate;
            } else {
                // If it's not present, scanArg returns null.
                const arg = this.scanArg(param.type);
                if (arg) {
                    args.push(arg);
                } else {
                    // Report an error
                    this.onError({ code: 'missing-argument' });
                    args.push(this.placeholder());
                }
            }
            i += 1;
        }
        return [explicitGroup, args];
    }
    parseCommand(command: string): boolean {
        if (this.hasCommand(command)) {
            this.index++;
            return true;
        }
        return false;
    }
    parseLiteral(literal: string): boolean {
        if (this.hasLiteral(literal)) {
            this.index++;
            return true;
        }
        return false;
    }
    parseFiller(): boolean {
        let skipped = false;
        let done = false;
        do {
            const skippedSpace = this.skipWhitespace();
            const skippedRelax = this.parseCommand('relax');
            skipped = skipped || skippedSpace || skippedRelax;
            done = !skippedSpace && !skippedRelax;
        } while (!done);
        return skipped;
    }
    /**
     * Keywords are used to specify dimensions, and for various other
     * syntactic constructs. Unlike commands, they are not case sensitive.
     * There are 25 keywords:
     * at by bp cc cm dd depth em ex fil fill filll height in minus
     * mm mu pc plus pt sp spread to true width
     *
     * TeX: 8212
     * @return true if the expected keyword is present
     */
    parseKeyword(keyword: string): boolean {
        const savedIndex = this.index;
        let done = this.end();
        let value = '';
        while (!done) {
            const token = this.get();
            if (token?.type === 'literal') {
                value += token.value;
            }
            done =
                this.end() ||
                token?.type !== 'literal' ||
                value.length >= keyword.length;
        }
        const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
        if (!hasKeyword) {
            this.index = savedIndex;
        }
        return hasKeyword;
    }
    /**
     * Return a sequence of characters as a string.
     * i.e. 'abcd' returns 'abcd'.
     * Terminates on the first non-character encountered
     * e.g. '{', '}' etc...
     * Will also terminate on ']'
     */
    scanString(): string {
        let result = '';
        let done = this.end();
        while (!done) {
            if (this.hasLiteral(']')) {
                done = true;
            } else if (this.hasToken('literal')) {
                result += this.get()!.value;
            } else if (this.skipWhitespace()) {
                result += ' ';
            } else if (this.hasToken('command')) {
                const token = this.get();
                if (token!.value === 'space') {
                    // The 'space' command is the ~
                    // which can be used for example in operator names, i.e.
                    // \operatorname{lim~inf}. It's interpreted as a nbs
                    result += '\u00a0'; // NO-BREAK SPACE
                } else {
                    // TeX will give a 'Missing \endcsname inserted' error
                    // if it encounters any command when expecting a string.
                    // We're a bit more lax.
                    this.onError({ code: 'unbalanced-braces' });
                    result += token!.value;
                }
            } else {
                done = true;
            }
            done = done || this.end();
        }
        return result;
    }
    /**
     * Return the literal tokens, as a string, until a matching closing "}"
     */
    scanLiteralArg(): string {
        let result = '';
        if (this.hasToken('{')) {
            this.get(); // Skip initial "{"
            let depth = 1;
            while (depth > 0 && !this.end()) {
                const token = this.get()!;
                if (token.type === 'space') {
                    result += ' ';
                } else if (token.type === '#') {
                    result += '#' + token.value;
                } else if (token.type === 'command') {
                    result += '\\' + token.value;
                } else if (token.type === '}') {
                    depth -= 1;
                    if (depth > 0) {
                        // Don't include final '}'
                        result += '}';
                    }
                } else if (token.type === '{') {
                    depth += 1;
                    result += '{';
                } else {
                    result += token.value;
                }
            }
        }
        return result;
    }
    /**
     * Return a CSS color (#rrggbb)
     */
    scanColor(): string {
        return stringToColor(this.scanString());
    }
    /**
     * Return as a number a group of characters representing a
     * numerical quantity.
     *
     * From TeX:8695 (scan_int):
     * An integer number can be preceded by any number of spaces and `\.+' or
     * `\.-' signs. Then comes either a decimal constant (i.e., radix 10), an
     * octal constant (i.e., radix 8, preceded by~\.\'), a hexadecimal constant
     * (radix 16, preceded by~\."), an alphabetic constant (preceded by~\.\`), or
     * an internal variable.
     */
    scanNumber(isInteger = true): number {
        const negative = this.parseLiteral('-');
        // Optional (ignorable) '+' sign
        if (!negative) this.parseLiteral('+');
        this.skipWhitespace();
        isInteger = !!isInteger;
        let radix = 10;
        let digits = /[0-9]/;
        if (this.parseLiteral("'")) {
            // Apostrophe indicates an octal value
            radix = 8;
            digits = /[0-7]/;
            isInteger = true;
        } else if (this.parseLiteral('"') || this.parseLiteral('x')) {
            // Double-quote indicates a hex value
            // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
            // For example: 'x3a'
            radix = 16;
            // Hex digits have to be upper-case
            digits = /[0-9A-F]/;
            isInteger = true;
        }
        let value = '';
        while (this.hasLiteralPattern(digits)) {
            value += this.get()!.value;
        }
        // Parse the fractional part, if applicable
        if (!isInteger && (this.parseLiteral('.') || this.parseLiteral(','))) {
            value += '.';
            while (this.hasLiteralPattern(digits)) {
                value += this.get()!.value;
            }
        }
        const result = isInteger ? parseInt(value, radix) : parseFloat(value);
        return negative ? -result : result;
    }
    /**
     * Return as a floating point number a dimension in pt (1 em = 10 pt)
     *
     * See TeX:8831
     * @todo: note that some units depend on the font (em, ex). So it might be
     * better to return a dimen struct with the value + unit and resolve
     * later when we have a font context....
     */
    scanDimen(): number {
        const value = this.scanNumber(false);
        this.skipWhitespace();
        let result;
        if (this.parseKeyword('pt')) {
            result = convertDimenToEm(value, 'pt');
        } else if (this.parseKeyword('mm')) {
            result = convertDimenToEm(value, 'mm');
        } else if (this.parseKeyword('cm')) {
            result = convertDimenToEm(value, 'cm');
        } else if (this.parseKeyword('ex')) {
            result = convertDimenToEm(value, 'ex');
        } else if (this.parseKeyword('px')) {
            result = convertDimenToEm(value, 'px');
        } else if (this.parseKeyword('em')) {
            result = convertDimenToEm(value, 'em');
        } else if (this.parseKeyword('bp')) {
            result = convertDimenToEm(value, 'bp');
        } else if (this.parseKeyword('dd')) {
            result = convertDimenToEm(value, 'dd');
        } else if (this.parseKeyword('pc')) {
            result = convertDimenToEm(value, 'pc');
        } else if (this.parseKeyword('in')) {
            result = convertDimenToEm(value, 'in');
        } else if (this.parseKeyword('mu')) {
            result = convertDimenToEm(value, 'mu');
        } else {
            // If the units are missing, TeX assumes 'pt'
            this.onError({ code: 'missing-unit' });
            result = convertDimenToEm(value, 'pt');
        }
        return result;
    }
    scanSkip(): number {
        const result = this.scanDimen();
        // We parse, but ignore the optional 'plus' and 'minus'
        // arguments.
        this.skipWhitespace();
        // 'plus', optionally followed by 'minus'
        // ('minus' cannot come before 'plus')
        // dimen or 'hfill'
        if (this.parseKeyword('plus')) {
            // @todo there could also be a \hFilLlL command here
            this.scanDimen();
        }
        this.skipWhitespace();
        if (this.parseKeyword('minus')) {
            // @todo there could also be a \hFilLlL command here
            this.scanDimen();
        }
        return result;
    }
    scanColspec(): Colspec[] {
        this.skipWhitespace();
        const result: Colspec[] = [];
        while (!this.end() && !(this.hasToken('}') || this.hasLiteral(']'))) {
            if (this.hasLiteral()) {
                const literal = this.get()!.value as string;
                if ('lcr'.includes(literal)) {
                    result.push({ align: literal as 'l' | 'c' | 'r' });
                } else if (literal === '|') {
                    result.push({ rule: true });
                } else if (literal === '@') {
                    if (this.parseToken('{')) {
                        const savedParsemode = this.swapParseMode('math');
                        result.push({
                            gap: this.scanImplicitGroup(
                                (token) => token.type === '}'
                            ),
                        });
                        this.swapParseMode(savedParsemode);
                    }
                    this.parseToken('}');
                }
            }
        }
        return result;
    }
    /**
     * Parse a `\(...\)` or `\[...\]` sequence
     * @return group for the sequence or null
     */
    scanModeSet(): Atom {
        let final: string;
        if (this.parseCommand('(')) final = ')';
        if (!final && this.parseCommand('[')) final = ']';
        if (!final) return null;
        const savedParsemode = this.swapParseMode('math');
        const result = new Atom('math', 'group');
        result.mathstyle = final === ')' ? 'textstyle' : 'displaystyle';
        result.body = this.scanImplicitGroup(
            (token: Token) => token.type === 'command' && token.value === final
        );
        this.parseCommand(final);
        this.swapParseMode(savedParsemode);
        if (!result.body || result.body.length === 0) return null;
        return result;
    }
    /**
     * Parse a `$...$` or `$$...$$` sequence
     */
    scanModeShift(): Atom {
        if (!this.hasToken('$') && !this.hasToken('$$')) return null;
        const final = this.get()!.type;
        const result = new Atom('math', 'group');
        result.mathstyle = final === '$' ? 'textstyle' : 'displaystyle';
        result.latexOpen = result.mathstyle === 'textstyle' ? '$' : '$$';
        result.latexClose = result.latexOpen;
        const savedParsemode = this.swapParseMode('math');
        result.body = this.scanImplicitGroup(
            (token: Token) => token.type === final
        );
        this.parseToken(final);
        this.swapParseMode(savedParsemode);
        if (!result.body || result.body.length === 0) return null;
        return result;
    }
    /**
     * Parse a \begin{env}...\end{end} sequence
     */
    scanEnvironment(): Atom {
        // An environment starts with a \begin command
        if (!this.parseCommand('begin')) return null;
        // The \begin command is immediately followed by the environment
        // name, as a string argument
        const envName = this.scanArg('string') as string;
        const env = getEnvironmentInfo(envName);
        // If the environment has some arguments, parse them
        const args: (
            | string
            | number
            | BBoxParam
            | Colspec[]
            | Atom
            | Atom[]
        )[] = [];
        if (env?.params) {
            for (const param of env.params) {
                // Parse an argument
                if (param.isOptional) {
                    // If it's not present, scanArg returns null,
                    // but push it on the list of arguments anyway.
                    // The null value will be interpreted as unspecified
                    // optional value by the command parse function.
                    args.push(this.scanOptionalArg(param.type));
                } else {
                    const arg = this.scanArg(param.type);
                    if (!arg) {
                        this.onError({
                            code: 'missing-argument',
                            arg: envName,
                        });
                    }
                    args.push(arg);
                }
            }
        }
        // Some environments change the mode
        const savedMode = this.parseMode;
        const savedTabularMode = this.tabularMode;
        const savedMathList = this.swapMathList([]);
        // @todo: since calling scanImplicitGroup(), may not need to save/restore the mathlist
        this.tabularMode = env.tabular;
        const array: Atom[][][] = [];
        const rowGaps: number[] = [];
        let row: Atom[][] = [];
        let done = false;
        do {
            if (this.end()) {
                this.onError({ code: 'unbalanced-environment', arg: envName });
                done = true;
            }
            if (!done && this.parseCommand('end')) {
                done = this.scanArg('string') === envName;
            }
            if (!done) {
                if (this.parseColumnSeparator()) {
                    row.push(this.swapMathList([]));
                } else if (this.parseRowSeparator()) {
                    row.push(this.swapMathList([]));
                    let gap = 0;
                    this.skipWhitespace();
                    if (this.parseLiteral('[')) {
                        gap = this.scanDimen();
                        this.skipWhitespace();
                        this.parseLiteral(']');
                    }
                    rowGaps.push(gap || 0);
                    array.push(row);
                    row = [];
                } else {
                    this.mathList = this.mathList.concat(
                        this.scanImplicitGroup(
                            (token: Token) =>
                                token.type === '}' ||
                                (token.type === 'literal' &&
                                    token.value === '&') ||
                                (token.type === 'command' &&
                                    /^(end|cr|\\)$/.test(token.value as string)) // @revisit
                        )
                    );
                }
            }
        } while (!done);
        row.push(this.swapMathList([]));
        if (row.length > 0) array.push(row);
        const newMathList = this.swapMathList(savedMathList);
        // If we're in tabular mode, we should end up with an empty mathlist
        console.assert(
            !this.tabularMode || newMathList.length === 0,
            'Leftover atoms in tabular mode'
        );
        this.parseMode = savedMode;
        this.tabularMode = savedTabularMode;
        if (!env.tabular && newMathList.length === 0) return null;
        if (env.tabular && array.length === 0) return null;
        const result = new Atom(
            this.parseMode,
            'array',
            newMathList,
            env.parser ? env.parser(envName, args, array) : {}
        );
        result.array = array;
        result.rowGaps = rowGaps;
        result.env = { ...env };
        result.env.name = envName;
        return result;
    }
    /**
     * Parse a sequence terminated with a group end marker, such as
     * `}`, `\end`, `&`, etc...
     *
     * Returns an array of atoms or an empty array if the sequence
     * terminates right away.
     *
     * @param done - A predicate indicating if a
     * token signals the end of an implicit group
     */
    scanImplicitGroup(done?: (token: Token) => boolean): Atom[] {
        // An implicit group is a sequence of atoms that terminates with
        // a `'}'`,
        // For environments, they also terminate at
        // `'&'`, `'\'`, `'\cr'` or `'\end'` or the end of the stream
        // and a specific 'done' callback is passed for that
        const savedStyle = this.style;
        if (!done) {
            done = (token: Token): boolean => token.type === '}';
        }
        // To handle infix commands, we'll keep track of their prefix
        // (tokens coming before them) and their arguments
        let infix: Token | null = null;
        let infixInfo = null;
        let infixArgs: Atom[][] = [];
        let prefix = null; // A mathlist
        const savedMathlist = this.swapMathList([]);
        // if (this.index >= this.tokens.length) return true;
        // const token = this.tokens[this.index];
        while (!this.end() && !done(this.peek())) {
            if (
                this.hasImplicitCommand([
                    'displaystyle',
                    'textstyle',
                    'scriptstyle',
                    'scriptscriptstyle',
                ])
            ) {
                // Implicit math style commands such as \displaystyle, \textstyle...
                // Note these commands switch to math mode and a specific size
                // \textsize is the mathstyle used for inlinemath, not for text
                this.parseMode = 'math';
                const atom = new Atom('math', 'mathstyle');
                atom.mathstyle = this.get()!.value as
                    | 'displaystyle'
                    | 'textstyle'
                    | 'scriptstyle'
                    | 'scriptscriptstyle';
                this.mathList.push(atom);
            } else if (this.hasInfixCommand() && !infix) {
                // The next token is an infix and we have not seen one yet
                // (there can be only one infix command per implicit group).
                infix = this.get();
                // The current parseMode, this.parseMode, may no longer have the value
                // it had when we encountered the infix. However, since all infix are
                // only defined in 'math' mode, we can use the 'math' constant
                // for the parseMode
                infixInfo = getInfo('\\' + infix.value, 'math', this.macros);
                if (infixInfo) {
                    [, infixArgs] = this.parseArguments(infixInfo) as [
                        ParseModePrivate,
                        Atom[][]
                    ];
                }
                // Save the math list so far and start a new one
                prefix = this.swapMathList([]);
            } else {
                this.parseAtom();
            }
        }
        let result: Atom[];
        if (infix) {
            console.assert(infixInfo);
            infixArgs.unshift(this.swapMathList(savedMathlist)); // suffix
            infixArgs.unshift(prefix);
            result = [
                new Atom(
                    this.parseMode,
                    infixInfo.type,
                    infixInfo.value || infix.value, // Functions don't have
                    infixInfo.parse
                        ? infixInfo.parse('\\' + infix.value, infixArgs)
                        : null
                ),
            ];
            result[0].symbol = '\\' + infix.value;
        } else {
            result = this.swapMathList(savedMathlist);
        }

        this.style = savedStyle;

        return result;
    }
    /**
     * Parse a group enclosed in a pair of braces: `{...}`.
     *
     * Return either a group Atom or null if not a group.
     *
     * Return a group Atom with an empty body if an empty
     * group (i.e. `{}`).
     */
    scanGroup(): Atom {
        if (!this.parseToken('{')) return null;
        const result = new Atom(this.parseMode, 'group');
        result.body = this.scanImplicitGroup(
            (token: Token) => token.type === '}'
        );
        this.parseToken('}');
        result.latexOpen = '{';
        result.latexClose = '}';
        return result;
    }
    scanSmartFence(): Atom {
        this.skipWhitespace();
        if (!this.parseLiteral('(')) return null;
        // We've found an open paren... Convert to a `\mleft...\mright`
        const result = new Atom(this.parseMode, 'leftright');
        result.leftDelim = '(';
        result.inner = false; // It's a `\mleft`, not a `\left`
        const savedMathList = this.swapMathList([]);
        let nestLevel = 1;
        while (!this.end() && nestLevel !== 0) {
            if (this.hasLiteral('(')) nestLevel += 1;
            if (this.hasLiteral(')')) nestLevel -= 1;
            if (nestLevel !== 0) this.parseAtom();
        }
        if (nestLevel === 0) this.parseLiteral(')');
        result.rightDelim = nestLevel === 0 ? ')' : '?';
        result.body = this.swapMathList(savedMathList);
        return result;
    }
    /**
     * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
     *
     * @return The delimiter (as a character or command) or null
     */
    scanDelim(): string {
        this.skipWhitespace();
        const token = this.get();
        if (!token) {
            this.onError({ code: 'unexpected-end-of-string' });
            return null;
        }
        let delim = '.';
        if (token.type === 'command') {
            delim = '\\' + token.value;
        } else if (token.type === 'literal') {
            delim = token.value as string;
        }
        const info = getInfo(delim, 'math', this.macros);
        if (!info) {
            this.onError({ code: 'unknown-command', arg: delim });
            return null;
        }
        if (info.mode && !info.mode.includes(this.parseMode)) {
            this.onError({ code: 'unexpected-delimiter', arg: delim });
            return null;
        }
        if (info.type === 'mopen' || info.type === 'mclose') {
            return delim;
        }
        // Some symbols are not of type mopen/mclose, but are still
        // valid delimiters...
        // '?' is a special delimiter used as a 'placeholder'
        // (when the closing delimiter is displayed greyed out)
        if (
            /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
                delim
            )
        ) {
            return delim;
        }
        this.onError({ code: 'unexpected-delimiter', arg: delim });
        return null;
    }
    /**
     * Parse a `/left.../right` sequence.
     *
     * Note: the `/middle` command can occur multiple times inside a
     * `/left.../right` sequence, and is handled separately.
     *
     * Return either an atom of type `'leftright'` or null
     */
    scanLeftRight(): Atom {
        if (this.parseCommand('right') || this.parseCommand('mright')) {
            // We have an unbalanced left/right (there's a \right, but no \left)
            this.onError({ code: 'unbalanced-braces' });
            return null;
        }

        const savedStyle = this.style;

        let close = 'right';
        if (!this.parseCommand('left')) {
            if (!this.parseCommand('mleft')) return null;
            close = 'mright';
        }
        const leftDelim = this.scanDelim();
        if (!leftDelim) return null;

        const savedMathList = this.swapMathList([]);
        while (!this.end() && !this.parseCommand(close)) {
            this.parseAtom();
        }
        this.style = savedStyle;

        // If we've reached the end and there was no `\right` or
        // there isn't a valid delimiter after `\right`, we'll
        // consider the `\right` missing and set the `rightDelim` to undefined
        const rightDelim = this.scanDelim();

        const result = new Atom(this.parseMode, 'leftright');
        result.leftDelim = leftDelim;
        result.rightDelim = rightDelim;
        result.inner = close === 'right';
        result.body = this.swapMathList(savedMathList);
        return result;
    }
    /**
     * Parse a subscript/superscript: `^` and `_`.
     *
     * Modify the last atom accordingly.
     *
     */
    parseSupSub(): boolean {
        // No sup/sub in text or command mode.
        if (this.parseMode !== 'math') return false;
        // Apply the subscript/superscript to the last render atom.
        // If none is present (beginning of the mathlist, i.e. `{^2}`,
        // an empty atom will be created, equivalent to `{{}^2}`
        let result = false;
        while (
            this.hasLiteral('^') ||
            this.hasLiteral('_') ||
            this.hasLiteral("'")
        ) {
            const supsub = this.hasLiteral('^') ? 'superscript' : 'subscript';
            if (this.parseLiteral('^') || this.parseLiteral('_')) {
                const arg = this.scanArg();
                if (arg) {
                    const atom = this.lastMathAtom();
                    atom[supsub] = atom[supsub] || [];
                    atom[supsub] = atom[supsub].concat(arg as Atom[]);
                    result = true;
                }
            } else if (this.parseLiteral("'")) {
                // A single quote (prime) is actually equivalent to a
                // '^{\prime}'
                const base = this.lastMathAtom();
                const atom = new Atom(base.mode, 'mord', '\u2032');
                atom.symbol = '\\prime';
                base.superscript = base.superscript || [];
                base.superscript.push(atom);
                result = true;
            }
        }
        return result;
    }
    /**
     * Parse a `\limits` or `\nolimits` command.
     *
     * This will change the placement of limits to be either above or below
     * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
     *
     * This overrides the calculation made for the placement, which is usually
     * dependent on the displaystyle (`inlinemath` prefers `\nolimits`, while
     * `displaymath` prefers `\limits`).
     */
    parseLimits(): boolean {
        // Note: technically, \limits and \nolimits are only applicable
        // after an operator. However, we apply them in all cases. They
        // will simply be ignored when not applicable (i.e. on a literal)
        // which is actually consistent with TeX.
        if (this.parseCommand('limits')) {
            const lastAtom = this.lastMathAtom();
            lastAtom.limits = 'limits';
            // Record that the limits was set through an explicit command
            // so we can generate the appropriate LaTeX later
            lastAtom.explicitLimits = true;
            return true;
        }
        if (this.parseCommand('nolimits')) {
            const lastAtom = this.lastMathAtom();
            lastAtom.limits = 'nolimits';
            // Record that the limits was set through an explicit command
            // so we can generate the appropriate LaTeX later
            lastAtom.explicitLimits = true;
            return true;
        }
        return false;
    }
    scanOptionalArg(
        parseMode: ParseModePrivate
    ): string | number | BBoxParam | Colspec[] | Atom[] {
        parseMode =
            !parseMode || parseMode === 'auto' ? this.parseMode : parseMode;
        this.skipWhitespace();
        if (!this.parseLiteral('[')) return null;
        const savedParseMode = this.parseMode;
        this.parseMode = parseMode;
        const savedMathlist = this.swapMathList();
        let result: string | number | BBoxParam | Colspec[] | Atom[];
        while (!this.end() && !this.parseLiteral(']')) {
            if (parseMode === 'string') {
                result = this.scanString();
            } else if (parseMode === 'number') {
                result = this.scanNumber();
            } else if (parseMode === 'dimen') {
                result = this.scanDimen();
            } else if (parseMode === 'skip') {
                result = this.scanSkip();
            } else if (parseMode === 'colspec') {
                result = this.scanColspec();
            } else if (parseMode === 'color') {
                result = this.scanColor() || '#ffffff';
            } else if (parseMode === 'bbox') {
                // The \bbox command takes a very particular argument:
                // a comma delimited list of up to three arguments:
                // a color, a dimension and a string.
                // Split the string by comma delimited sub-strings, ignoring commas
                // that may be inside (). For example"x, rgb(a, b, c)" would return
                // ['x', 'rgb(a, b, c)']
                const list = this.scanString()
                    .toLowerCase()
                    .trim()
                    .split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
                const bboxParam: BBoxParam = {};
                for (const elem of list) {
                    const color = stringToColor(elem);
                    if (color) {
                        bboxParam.backgroundcolor = color;
                    } else {
                        const m = elem.match(/^\s*([0-9.]+)\s*([a-z][a-z])/);
                        if (m) {
                            bboxParam.padding = convertDimenToEm(m[1], m[2]);
                        } else {
                            const m = elem.match(/^\s*border\s*:\s*(.*)/);
                            if (m) {
                                bboxParam.border = m[1];
                            }
                        }
                    }
                }
                result = bboxParam;
            } else {
                console.assert(
                    parseMode === 'math',
                    'Unexpected parse mode: "' + parseMode + '"'
                );
                this.mathList = this.mathList.concat(
                    this.scanImplicitGroup(
                        (token) =>
                            token.type === 'literal' && token.value === ']'
                    )
                );
            }
        }
        this.parseMode = savedParseMode;
        const mathList = this.swapMathList(savedMathlist);
        return result ? result : mathList;
    }
    /**
     * Parse a math field, an argument to a function.
     *
     * An argument can either be a single atom or
     * a sequence of atoms enclosed in braces.
     *
     * @param parseMode Temporarily overrides the parser parsemode. For
     * example: `'dimen'`, `'color'`, `'text'`, etc...
     */
    scanArg(
        parseMode?: ParseModePrivate
    ): string | number | Atom | Atom[] | Colspec[] {
        parseMode =
            !parseMode || parseMode === 'auto' ? this.parseMode : parseMode;
        this.parseFiller();
        let result: string | number | Atom | Atom[] | Colspec[];
        // An argument (which is called a 'math field' in TeX)
        // could be a single character or symbol, as in `\frac12`
        // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
        // ``\frac{\sqrt}{-1}{\beta}``
        if (!this.parseToken('{')) {
            if (parseMode === 'delim') {
                return this.scanDelim() || '.';
            } else if (/^(math|text)$/.test(parseMode)) {
                // Parse a single token.
                const savedParseMode = this.parseMode;
                this.parseMode = parseMode;
                const atom = this.scanToken();
                this.parseMode = savedParseMode;
                return atom;
            }
        }
        // If this is a param token, substitute it with the
        // (optional) argument passed to the parser
        if (this.hasToken('#')) {
            const paramToken = this.get();
            this.skipUntilToken('}');
            if (paramToken.value === '?') {
                return this.placeholder();
            }
            if (this.args) {
                if (
                    this.args[paramToken.value] === null ||
                    typeof this.args[paramToken.value] === 'undefined'
                ) {
                    return this.placeholder();
                }
                return typeof this.args[paramToken.value] === 'string'
                    ? parseString(
                          this.args[paramToken.value],
                          this.parseMode,
                          null,
                          this.macros,
                          false,
                          this.onError
                      )
                    : this.args[paramToken.value] ?? null;
            }
            return null;
        }
        const savedParseMode = this.parseMode;
        this.parseMode = parseMode;
        const savedMathList = this.swapMathList([]);
        if (parseMode === 'string') {
            result = this.scanString();
            this.skipUntilToken('}');
        } else if (parseMode === 'number') {
            result = this.scanNumber();
            this.skipUntilToken('}');
        } else if (parseMode === 'dimen') {
            result = this.scanDimen();
            this.skipUntilToken('}');
        } else if (parseMode === 'skip') {
            result = this.scanSkip();
            this.skipUntilToken('}');
        } else if (parseMode === 'colspec') {
            result = this.scanColspec();
            this.skipUntilToken('}');
        } else if (parseMode === 'color') {
            result = this.scanColor() || '#ffffff';
            this.skipUntilToken('}');
        } else if (parseMode === 'delim') {
            result = this.scanDelim() || '.';
            this.skipUntilToken('}');
        } else {
            console.assert(
                /^(math|text)$/.test(parseMode),
                'Unexpected parse mode: "' + parseMode + '"'
            );

            // Collect an array of tokens until a balanced "}"
            const initialIndex = this.index;
            let depth = 1;
            do {
                const token = this.get();
                if (token.type === '}') depth -= 1;
                if (token.type === '{') depth += 1;
            } while (depth > 0 && !this.end());
            result = parseTokens(
                parseMode,
                this.tokens.slice(initialIndex, this.index - 1),
                this.onError,
                {
                    args: this.args,
                    macros: this.macros,
                    smartFence: this.smartFence,
                    style: this.style,
                    parse: (
                        mode: ParseModePrivate,
                        tokens: Token[],
                        options
                    ): [Atom[], Token[]] => {
                        const parser = new Parser(
                            tokens,
                            options.args,
                            options.macros,
                            this.onError
                        );
                        parser.parseMode = mode;
                        parser.style = options.style;
                        result = parser.scanImplicitGroup();
                        return [result, tokens.slice(parser.index)];
                    },
                }
            );
            if (!result) {
                // No mode-specific result. Try again from the start
                this.index = initialIndex;
                do {
                    this.mathList = this.mathList.concat(
                        this.scanImplicitGroup()
                    );
                } while (!this.parseToken('}') && !this.end());
            }
        }
        this.parseMode = savedParseMode;
        const mathList = this.swapMathList(savedMathList);
        return result ? result : mathList;
    }

    scanToken(): Atom[] {
        const token = this.get();
        if (!token) return null;
        let result: Atom | Atom[] | null = null;
        if (token.type === 'space') {
            if (this.parseMode === 'text') {
                result = new Atom('text', '', ' ', this.style);
                result.symbol = ' ';
            }
        } else if (token.type === 'placeholder') {
            // RENDER PLACEHOLDER
            result = new Atom(
                this.parseMode,
                'placeholder',
                token.value as string
            );
            result.captureSelection = true;
        } else if (token.type === 'command') {
            // RENDER COMMAND
            if (token.value === 'placeholder') {
                result = new Atom(
                    this.parseMode,
                    'placeholder',
                    this.scanArg('string') as string,
                    this.style
                );
                result.captureSelection = true;
            } else if (token.value === 'char') {
                // \char has a special syntax and requires a non-braced integer
                // argument
                const initialIndex = this.index;
                let codepoint = Math.floor(this.scanNumber(true));
                if (
                    !isFinite(codepoint) ||
                    codepoint < 0 ||
                    codepoint > 0x10ffff
                ) {
                    codepoint = 0x2753; // BLACK QUESTION MARK
                }
                result = new Atom(
                    this.parseMode,
                    this.parseMode === 'math' ? 'mord' : '',
                    String.fromCodePoint(codepoint)
                );
                result.symbol = '\\char';
                result.latex =
                    '\\char' + tokensToString(this.tokens.slice(initialIndex));
            } else if (token.value === 'hskip' || token.value === 'kern') {
                // \hskip and \kern have a special syntax and requires a non-braced
                // 'skip' argument
                const width = this.scanSkip();
                if (isFinite(width)) {
                    result = new Atom(
                        this.parseMode,
                        'spacing',
                        null,
                        this.style
                    );
                    result.width = width;
                    result.symbol = '\\' + token.value;
                    result.latex = '\\' + token.value;
                }
            } else {
                result = this.scanMacro(token.value as string);
                if (!result) {
                    // This wasn't a macro, so let's see if it's a regular command
                    const info = getInfo(
                        '\\' + token.value,
                        this.parseMode,
                        {}
                    );

                    if (!info) {
                        // An unknown command
                        this.onError({
                            code: 'unknown-command',
                            arg: '\\' + token.value,
                        });
                        result = new Atom('math', 'error', '\\' + token.value);
                        result.symbol = '\\' + token.value;
                        result.latex = '\\' + token.value;
                        return [result];
                    }

                    if (info.mode && !info.mode.includes(this.parseMode)) {
                        // Command invalid in this mode
                        this.onError({
                            code: 'invalid-command',
                            arg: '\\' + token.value,
                        });
                        result = new Atom('math', 'error', '\\' + token.value);
                        result.symbol = '\\' + token.value;
                        result.latex = '\\' + token.value;
                        return [result];
                    }

                    // Parse the arguments
                    // If explicitGroup is not empty, an explicit group is expected
                    // to follow the command and will be parsed *after* the
                    // command has been processed.
                    // This is used for commands such as \textcolor{color}{content}
                    // that need to apply the color to the content *after* the
                    // style has been changed.
                    // In definitions, this is indicated with a parameter type
                    // of 'auto*'
                    const initialIndex = this.index;
                    const [explicitGroup, args] = this.parseArguments(info);

                    if (!args) return null; // Some required arguments were missing...

                    if (info.infix) {
                        // Infix commands should be handled in scanImplicitGroup
                        // If we find an infix command here, it's a syntax error
                        // (second infix command in an implicit group) and should be ignored.
                        this.onError({
                            code: 'too-many-infix-commands',
                            arg: '\\' + token.value,
                        });
                    } else {
                        //  Invoke the parse() function if present
                        if (info.parse) {
                            const attributes = info.parse(
                                '\\' + token.value,
                                args
                            );
                            if (attributes.type) {
                                // A type was provided: create a new Atom
                                result = new Atom(
                                    this.parseMode,
                                    info.type,
                                    explicitGroup
                                        ? (this.scanArg(
                                              explicitGroup
                                          ) as Atom[])
                                        : null,
                                    { ...this.style, ...attributes }
                                );
                            } else {
                                // No type provided -> the parse function will modify
                                // the current style rather than create a new Atom.
                                const savedMode = this.parseMode;
                                if (attributes.mode) {
                                    // Change to 'text' (or 'math') mode if necessary
                                    this.parseMode = attributes.mode;
                                    delete attributes.mode;
                                }

                                // If an explicit group is expected, process it now
                                if (explicitGroup) {
                                    // Create a temporary style
                                    const saveStyle = this.style;
                                    this.style = {
                                        ...this.style,
                                        ...attributes,
                                    };
                                    result = this.scanArg(
                                        explicitGroup
                                    ) as Atom[];
                                    this.style = saveStyle;
                                } else {
                                    // Merge the new style info with the current style
                                    this.style = {
                                        ...this.style,
                                        ...attributes,
                                    };
                                }
                                this.parseMode = savedMode;
                            }
                        } else {
                            // The new atom will inherit the style of this atom
                            // Only override the variant if it is not '' or undefined
                            const style = {
                                ...this.style,
                                variant: info.variant || this.style.variant,
                                variantStyle:
                                    info.variantStyle ||
                                    this.style.variantStyle,
                            };
                            result = new Atom(
                                this.parseMode,
                                info.type || 'mop',
                                info.value || (token.value as string),
                                style
                            );
                        }
                        if (
                            result instanceof Atom &&
                            !/^(llap|rlap|class|cssId)$/.test(
                                token.value as string
                            )
                        ) {
                            result.symbol = '\\' + token.value;
                            const argString = tokensToString(
                                this.tokens.slice(initialIndex, this.index)
                            );
                            if (argString) {
                                result.latex = result.symbol + argString;
                            }
                            if (result.isFunction && this.smartFence) {
                                // The atom was a function that may be followed by
                                // an argument, like `\sin(`
                                const smartFence = this.scanSmartFence();
                                if (smartFence) {
                                    result = [result, smartFence];
                                }
                            }
                        }
                    }
                }
            }
        } else if (
            token.type === 'literal' &&
            typeof token.value === 'string'
        ) {
            const info = getInfo(token.value, this.parseMode, this.macros);
            if (info) {
                const style = { ...this.style };
                result = new Atom(
                    this.parseMode,
                    info.type,
                    info.value || token.value,
                    style
                );
                if (info.isFunction) {
                    result.isFunction = true;
                }
            } else {
                result = new Atom(
                    this.parseMode,
                    this.parseMode === 'math' ? 'mord' : '',
                    token.value,
                    this.style
                );
            }
            result.symbol = token.value;
            result.latex = unicodeCharToLatex(this.parseMode, token.value);
            if (info?.isFunction && this.smartFence) {
                // The atom was a function that may be followed by
                // an argument, like `f(`.
                const smartFence = this.scanSmartFence();
                if (smartFence) {
                    result = [result, smartFence];
                }
            }
        } else if (token.type === '#') {
            // Parameter token
            if (token.value === '?' || !this.args) {
                // '#?' indicates that a placeholder should be used
                result = this.placeholder();
            } else {
                // Otherwise, substitute the token with a provided argument
                if (
                    this.args[token.value] === null ||
                    typeof this.args[token.value] === 'undefined'
                ) {
                    result = this.placeholder();
                } else if (typeof this.args[token.value] === 'string') {
                    result = parseString(
                        this.args[token.value],
                        this.parseMode,
                        [],
                        this.macros,
                        false,
                        this.onError
                    );
                } else {
                    result = this.args[token.value];
                }
            }
        } else {
            if (token.type === '}') {
                this.onError({ latex: '', code: 'unbalanced-braces' });
            } else {
                this.onError({
                    latex: '',
                    code: 'unexpected-token',
                    arg: token.type + (token.value ?? ''),
                });
            }
        }
        // Always return an array of atoms
        return result && !isArray(result)
            ? [result as Atom]
            : (result as Atom[]);
    }
    /**
     * Attempt to scan the macro name and return an atom list if successful.
     * Otherwise, it wasn't a macro.
     */
    scanMacro(macro: string): Atom {
        if (!this.macros || !this.macros[macro]) return null;
        const initialIndex = this.index;
        const args: (string | Atom[])[] = [];
        let def: string;
        let argCount = 0;
        if (typeof this.macros[macro] === 'string') {
            def = this.macros[macro] as string;
            // Let's see if there are arguments in the definition.
            if (/(^|[^\\])#1/.test(def)) argCount = 1;
            if (/(^|[^\\])#2/.test(def)) argCount = 2;
            if (/(^|[^\\])#3/.test(def)) argCount = 3;
            if (/(^|[^\\])#4/.test(def)) argCount = 4;
            if (/(^|[^\\])#5/.test(def)) argCount = 5;
            if (/(^|[^\\])#6/.test(def)) argCount = 6;
            if (/(^|[^\\])#7/.test(def)) argCount = 7;
            if (/(^|[^\\])#8/.test(def)) argCount = 8;
            if (/(^|[^\\])#9/.test(def)) argCount = 9;
        } else {
            def = (this.macros[macro] as MacroDefinition).def;
            argCount = (this.macros[macro] as MacroDefinition).args || 0;
        }
        for (let i = 1; i <= argCount; i++) {
            // Parse each argument as a string. We don't know yet
            // what the proper parse mode is, so defer parsing till later
            // when invoking `parseString`
            args[i] = this.scanLiteralArg();
        }
        // Carry forward the placeholder argument, if any.
        args['?'] = this.args?.['?'];

        // Group the result of the macro expansion, and set the
        // captureSelection attribute so that it is handled as an unbreakable
        // unit
        const atom = new Atom(
            this.parseMode,
            'group',
            parseString(
                def,
                this.parseMode,
                args,
                this.macros,
                false,
                this.onError
            )
        );
        atom.captureSelection = true;
        atom.symbol = '\\' + macro;
        atom.latex =
            '\\' + macro + tokensToString(this.tokens.slice(initialIndex));
        return atom;
    }
    /**
     * Make a Atom for the current token or token group and
     * add it to the parser's current mathList
     */
    parseAtom(): boolean {
        let result: Atom | Atom[] =
            this.scanEnvironment() ||
            this.scanModeShift() ||
            this.scanModeSet() ||
            this.scanGroup() ||
            this.scanLeftRight();
        if (!result && (this.parseSupSub() || this.parseLimits())) return true;
        if (!result) result = this.scanToken();
        // If we have an atom to add, push it at the end of the current math list
        // We could have no atom for tokens that were skipped, a ' ' in math mode
        // for example
        if (isArray(result)) {
            this.mathList = this.mathList.concat(result);
        } else if (result) {
            this.mathList.push(result);
        }
        return result !== null;
    }
}

/**
 * Given a string of LaTeX, return a corresponding math list (array of atoms).
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param smartFence - If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 */
export function parseString(
    s: string,
    parseMode: ParseModePrivate,
    args: (string | Atom[])[],
    macros: MacroDictionary,
    smartFence = false,
    error?: ParserErrorListener
): Atom[] {
    let mathlist = [];
    const parser = new Parser(tokenize(s), args, macros, (err) => {
        if (error) {
            error({ ...err, latex: s });
        } else {
            console.warn(
                'MathLive parsing error: ' +
                    err.code +
                    (err.arg ? ' ' + err.arg + ' ' : ''),
                'in "' + s + '"'
            );
        }
    });
    parser.parseMode = parseMode || 'math'; // other possible values: 'text', 'color', etc...
    if (smartFence) parser.smartFence = true;

    while (!parser.end()) {
        mathlist = mathlist.concat(parser.scanImplicitGroup());
    }
    return mathlist;
}
